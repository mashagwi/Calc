#include "../../s21_smartcalc.h"
#include "../../credit.h"
#include "../../deposit.h"

#test use_1
  char input[]="sin(3)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 0.14112000806, EPS);

#test use_01
  char input[]="4*- 1";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, -4, EPS);

#test use_2
  char input[]="14mod3^sin(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 1);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 1.39758733594, EPS);

#test use_3
  char input[]="14mod3/sin(2x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 2);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, -2.64269741762, EPS);

#test use_4
  char input[]="(14mod3^sin(x))";
  double result = 0;
  int response = s21_smartcalc(&result, input, 1);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 1.39758733594, EPS);

#test use_5
  char input[]="4*-1";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, -4, EPS);

#test use_6
  char input[]="tg(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 1.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, -34.2325327356, EPS);

#test use_7
  char input[]="ctg(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 1.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, -0.02921197819, EPS);

#test use_8
  char input[]="cos(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 1.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, -0.0291995223, EPS);

#test use_9
  char input[]="asin(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 0.643501109, EPS);

#test use_10
  char input[]="acos(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 0.927295218, EPS);

#test use_11
  char input[]="atg(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 0.5404195, EPS);

#test use_12
  char input[]="actg(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 1.03037683, EPS);

#test use_13
  char input[]="sqrt(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 0.77459666924, EPS);

#test use_14
  char input[]="ln(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, -0.51082562376 , EPS);

#test use_15
  char input[]="log(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, -0.22184874961, EPS);

#test use_16
  char input[]="1+1";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 2, EPS);

#test use_17
  char input[]="11-2";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0.6);
  ck_assert_int_eq(response, OK);
  ck_assert_double_eq_tol(result, 9, EPS);

#test nan1
  char input[]="-sin(3)^actg(x)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0);
  ck_assert_int_eq(response, OK);
  ck_assert_double_nan(result);

#test invalid1
  char input[]="-+sin(3)";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0);
  ck_assert_int_eq(response, INVALID_EXPRESSION);

  #test invalid2
  char input[]="sin(3";
  double result = 0;
  int response = s21_smartcalc(&result, input, 0);
  ck_assert_int_eq(response, INVALID_EXPRESSION);


  #test cr_use_1
    double sum = 1000000;
    int date = 1;
    double percent = 12;
    int credit_type = ANNUITET;
    double* monthly_pay = NULL;
    double over_pay = 0;
    double total_pay = 0;
    int response = calc_credit(sum, &date, 1, percent, credit_type, &monthly_pay, &over_pay, &total_pay);
    ck_assert_int_eq(response, OK);
    free(monthly_pay);
    monthly_pay = NULL;

  #test cr_use_2
    double sum = 1000000;
    int date = 12;
    double percent = 12;
    int credit_type = DIFFERENT;
    double* monthly_pay = NULL;
    double over_pay = 0;
    double total_pay = 0;
    int response = calc_credit(sum, &date, 0, percent, credit_type, &monthly_pay, &over_pay, &total_pay);
    ck_assert_int_eq(response, OK);
    free(monthly_pay);
    monthly_pay = NULL;


  #test dep_use_1
    long double sum = 1000000;
    int date = 12;
    long double percent = 12;
    long double tax = 12;
    int payment_period = 1;
    int cap_type = 0;
    double* in_arr = calloc(12, sizeof(double));
    double* out_arr = calloc(12, sizeof(double));
    long double dep_result = 0;
    long double total_tax = 0;

    int response = calc_deposit(&sum, date, percent, tax, payment_period, cap_type, in_arr, out_arr, &dep_result, &total_tax);
    ck_assert_int_eq(response, OK);
    free(in_arr);
    free(out_arr);
    in_arr = NULL;
    out_arr = NULL;

  #test dep_use_2
    long double sum = 1000000;
    int date = 12;
    long double percent = 12;
    long double tax = 12;
    int payment_period = 1;
    int cap_type = 1;
    double* in_arr = calloc(12, sizeof(double));
    double* out_arr = calloc(12, sizeof(double));
    long double dep_result = 0;
    long double total_tax = 0;

    int response = calc_deposit(&sum, date, percent, tax, payment_period, cap_type, in_arr, out_arr, &dep_result, &total_tax);
    ck_assert_int_eq(response, OK);
    free(in_arr);
    free(out_arr);
    in_arr = NULL;
    out_arr = NULL;

#main-pre
  srunner_set_fork_status (sr, CK_NOFORK);